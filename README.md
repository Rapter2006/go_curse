# Задание 1. Интерфейсы и структуры

Язык Go не навязывает использовать ООП для любой задачи.
При этом он имеет весь необходимый набор инструментов, чтобы работат в
объектно-ориентированной парадигме. Но реализация достаточно сильно
отличаются от подхода в PHP/Java, JavaScript.

И у большинства разработчиков не всегда софрмировано правильное понимание,
как лучше всего правильно использовать такие конструкции Go как:

- struct
- interface
- interface {}
- а как же без Generic?
- строгая типизация, но я хочу функцию которая будет работать с любым типом данных

Именно это мы и попрактикуем на нашем первом практическом задании, а затем
на занятии разберем идиомы и теорию, с оглядкой как это поможет в реальной
жизни разработчику.

## Deadline: 13 мая (воскресенье).

Ребят, всё просто — мы решили привлечь вас к разработке сервиса товарного поиска «Маркет» для Пятерки, потому все домашние задания будут про товары :)

Как я уже говорил, мы очень любим Agile подходы к разработке, потому будем разрабатывать MVP, и с каждым заданием шаг за шагом развивать наше приложение.

Пусть наш, пока очень упрощенный, товар описывается следующей структурой кода:

```go
package product

type Item struct {
  ID ItemID // Идентификатор товара
  Name string // Строка с названием товара
  Description string // Более подробное описание товара, выделяющее его отличительные признаки и предназначение
}

type ItemID string // Тип унаследованный от строки, для четкой идентификации товаров
```

# Первое задание — Хранилище (репозиторий) товаров

Начнем мы с того, что товары нужно где-то сохранять, и затем их искать в хранилище. Выберем самый простое место хранения объектов —  память.

## Задание
Нужно сделать компонент в отдельном пакете — хранилище данных, который будет иметь компонент для логирования как внешнюю зависимость, и позволять:

  - добавлять новые объекты товаров в хранилище
  - искать товар по ID
  - искать товары по подстроке в названии

Чтобы показать что все работает, в файле `part1.go` нужно сделать примеры добавления нескольких товаров, и затем поиск их по `product.ItemID` и подстроке в названии.

## Комментарии
Для отладки, при совершении операции,  удобно выводить промежуточные действия в лог — потому компонент хранилище использует внешнюю зависимость: компонент логгер.

Ограничимся тем, что нужно логировать сообщения с одним уровнем уровнем важности.

# Задание со звёздочкой — Иерархические категории*
Плоский список — это неплохо, но давайте добавим в наш каталог товаров иерархичность. А именно, сделаем возможность добавлять товары в категории, а категории в свою очередь можно вкладывать друг друга.

Пусть категория описывается объектом

```go
type Category struct {
  ID CategoryID
  Name string
}
```

Чтобы получилось как-то так:
- **Товары**
  - **Шины**
    - *Nokian Hakkapelitta-5 15 195X65*
    - ...
  - **Диски**
    - ...
- **Услуги**
    - … *какие-то услуги*

Где **жирным** выделены категории, а *курсивом* — товары.

## Задание
Нужно сделать реализацию структуры хранения данных nested set.

```go
type Node struct {
...
}
```

Интерфейс узла структуры данных содержит методы:
- добавления вложенных объектов - `Add(child *Node) error`
- возвращения списка вложенных объектов - `Children() []*Node`
- возвращения родительского узла - `ParentNode() *Node`


## Советы

Чтобы показать что все работает, в файле `part2.go` нужно
добавить пример построения иерархии категорий, что указана в задании,
добавить в них несколько товаров,
реализовать функцию, которая обходит все дерево категорий и собирает в список все найденные товары, а затем отобразить результат.

# p.s.
Не забывайте про тему задания — структуры и интерфейсы. Упор нужно сделать пока только на этом. Нет необходимости писать production код, забудьте пока про race condition и параллелизм, про внешние пакеты и зависимости, про обработку ошибок и сборку каркаса полность работающего API сервиса — к этому вернёмся в будущем.

